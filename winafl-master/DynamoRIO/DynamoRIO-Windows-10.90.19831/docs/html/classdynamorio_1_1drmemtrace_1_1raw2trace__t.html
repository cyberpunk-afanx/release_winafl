<!-- HTML header for doxygen 1.8.19-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.19"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<title>DynamoRIO: dynamorio::drmemtrace::raw2trace_t Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.19 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdynamorio_1_1drmemtrace_1_1raw2trace__t.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">dynamorio::drmemtrace::raw2trace_t Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;raw2trace.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5150d6f82583b9188c856d49e147b087"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#a5150d6f82583b9188c856d49e147b087">handle_custom_data</a> (const char *(*parse_cb)(const char *src, DR_PARAM_OUT void **data), std::string(*process_cb)(<a class="el" href="group__drcovlib.html#ga70dd4ae0fcab1e7c8c090977eeeefa02">drmodtrack_info_t</a> *info, void *data, void *user_data), void *process_cb_user_data, void(*free_cb)(void *data))</td></tr>
<tr class="separator:a5150d6f82583b9188c856d49e147b087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f874404ab4775be97a51499dd1d55e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#af3f874404ab4775be97a51499dd1d55e">do_module_parsing</a> ()</td></tr>
<tr class="separator:af3f874404ab4775be97a51499dd1d55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf37e4a9abaaaec9361b50cb90507323"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#adf37e4a9abaaaec9361b50cb90507323">do_module_parsing_and_mapping</a> ()</td></tr>
<tr class="separator:adf37e4a9abaaaec9361b50cb90507323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cb114025e727b1580ebe238a794eae"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#a13cb114025e727b1580ebe238a794eae">find_mapped_trace_address</a> (app_pc trace_address, DR_PARAM_OUT app_pc *mapped_address)</td></tr>
<tr class="separator:a13cb114025e727b1580ebe238a794eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2da19abbafbb382f11dd0a7790749f"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#a4d2da19abbafbb382f11dd0a7790749f">do_conversion</a> ()</td></tr>
<tr class="separator:a4d2da19abbafbb382f11dd0a7790749f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a26b9006cd8e3411a68fc7b2b2e33a393"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#a26b9006cd8e3411a68fc7b2b2e33a393">create_essential_header_entries</a> (byte *&amp;buf_ptr, int version, <a class="el" href="namespacedynamorio_1_1drmemtrace.html#a017717a4b9ef5ae1f6d1fef1df834baa">offline_file_type_t</a> file_type, thread_id_t tid, process_id_t pid)</td></tr>
<tr class="separator:a26b9006cd8e3411a68fc7b2b2e33a393"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac4f6f6f247a72c0e1a1cd27196381a6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#ac4f6f6f247a72c0e1a1cd27196381a6a">process_offline_entry</a> (raw2trace_thread_data_t *tdata, const offline_entry_t *in_entry, thread_id_t tid, DR_PARAM_OUT bool *end_of_record, DR_PARAM_OUT bool *last_bb_handled, DR_PARAM_OUT bool *flush_decode_cache)</td></tr>
<tr class="separator:ac4f6f6f247a72c0e1a1cd27196381a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff89209c8224d4de764fbe92ee86143"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#a3ff89209c8224d4de764fbe92ee86143">process_marker_additionally</a> (raw2trace_thread_data_t *tdata, <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295c">trace_marker_type_t</a> marker_type, uintptr_t marker_val, byte *&amp;buf, DR_PARAM_OUT bool *flush_decode_cache)</td></tr>
<tr class="separator:a3ff89209c8224d4de764fbe92ee86143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296eb19535563da011525fdde5d22369"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#a296eb19535563da011525fdde5d22369">read_header</a> (raw2trace_thread_data_t *tdata, DR_PARAM_OUT <a class="el" href="structdynamorio_1_1drmemtrace_1_1trace__header__t.html">trace_header_t</a> *header)</td></tr>
<tr class="separator:a296eb19535563da011525fdde5d22369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d746b7e5b7a6199a800f09966c7658"><td class="memItemLeft" align="right" valign="top">virtual const offline_entry_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#ab5d746b7e5b7a6199a800f09966c7658">get_next_entry</a> (raw2trace_thread_data_t *tdata)</td></tr>
<tr class="separator:ab5d746b7e5b7a6199a800f09966c7658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948c0f69e1b899be24ff096ea26de881"><td class="memItemLeft" align="right" valign="top">virtual const offline_entry_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#a948c0f69e1b899be24ff096ea26de881">get_next_entry_keep_prior</a> (raw2trace_thread_data_t *tdata)</td></tr>
<tr class="separator:a948c0f69e1b899be24ff096ea26de881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfbb7021372766b4dc61ae04979210e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#a3bfbb7021372766b4dc61ae04979210e">on_thread_end</a> (raw2trace_thread_data_t *tdata)</td></tr>
<tr class="separator:a3bfbb7021372766b4dc61ae04979210e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984ec1b674ac2f398600ab0a8ce918d1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#a984ec1b674ac2f398600ab0a8ce918d1">log</a> (uint level, const char *fmt,...)</td></tr>
<tr class="separator:a984ec1b674ac2f398600ab0a8ce918d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa5005defa3e5e815e1d092ef4a2bf0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#a7aa5005defa3e5e815e1d092ef4a2bf0">log_instruction</a> (uint level, app_pc decode_pc, app_pc orig_pc)</td></tr>
<tr class="separator:a7aa5005defa3e5e815e1d092ef4a2bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f00d9f03c626c96f9ff32678164b92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#a99f00d9f03c626c96f9ff32678164b92">process_next_thread_buffer</a> (raw2trace_thread_data_t *tdata, DR_PARAM_OUT bool *end_of_record)</td></tr>
<tr class="separator:a99f00d9f03c626c96f9ff32678164b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f878550d53070fb71296f1304e09e8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#ae6f878550d53070fb71296f1304e09e8">read_syscall_template_file</a> ()</td></tr>
<tr class="separator:ae6f878550d53070fb71296f1304e09e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2bfe59e602f51da667e864093bba009"><td class="memItemLeft" align="right" valign="top">app_pc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#ae2bfe59e602f51da667e864093bba009">get_first_app_pc_for_syscall_template</a> (int syscall_num)</td></tr>
<tr class="separator:ae2bfe59e602f51da667e864093bba009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8169c0bff3707183b249e3ef606f68bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#a8169c0bff3707183b249e3ef606f68bd">write_syscall_template</a> (raw2trace_thread_data_t *tdata, byte *&amp;buf, <a class="el" href="namespacedynamorio_1_1drmemtrace.html#a067f98c2dab7fe5329e2ba248836370e">trace_entry_t</a> *buf_base, int syscall_num)</td></tr>
<tr class="separator:a8169c0bff3707183b249e3ef606f68bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b23bb0d332c07aaa0cc15b6cdfc16c1"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; module_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#a7b23bb0d332c07aaa0cc15b6cdfc16c1">modvec_</a> () const</td></tr>
<tr class="separator:a7b23bb0d332c07aaa0cc15b6cdfc16c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54f20f0cb2c70e538f4a551ad76ed59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#ad54f20f0cb2c70e538f4a551ad76ed59">set_modvec_</a> (const std::vector&lt; module_t &gt; *modvec)</td></tr>
<tr class="separator:ad54f20f0cb2c70e538f4a551ad76ed59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32eb97dd9b8bfab23e1ffc18f1eab760"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdynamorio_1_1drmemtrace_1_1module__mapper__t.html">module_mapper_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#a32eb97dd9b8bfab23e1ffc18f1eab760">modmap_</a> () const</td></tr>
<tr class="separator:a32eb97dd9b8bfab23e1ffc18f1eab760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39a7bfc8954256a2d913050bc8f4e7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#af39a7bfc8954256a2d913050bc8f4e7a">set_modmap_</a> (const <a class="el" href="classdynamorio_1_1drmemtrace_1_1module__mapper__t.html">module_mapper_t</a> *modmap)</td></tr>
<tr class="separator:af39a7bfc8954256a2d913050bc8f4e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2b0392de28b8cef6c9edc3971bb8e2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#adb2b0392de28b8cef6c9edc3971bb8e2">is_maybe_blocking_syscall</a> (uintptr_t number)</td></tr>
<tr class="separator:adb2b0392de28b8cef6c9edc3971bb8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4c39c4bc5c0dfd521c94e345939e7214"><td class="memItemLeft" align="right" valign="top">void *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#a4c39c4bc5c0dfd521c94e345939e7214">dcontext_</a></td></tr>
<tr class="separator:a4c39c4bc5c0dfd521c94e345939e7214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba91423f830ff5fbaa739a40d3d80dde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#aba91423f830ff5fbaa739a40d3d80dde">passed_dcontext_</a> = false</td></tr>
<tr class="separator:aba91423f830ff5fbaa739a40d3d80dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a2541ab899e27a3d31ac108180a670541"><td class="memItemLeft" align="right" valign="top">static const uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#a2541ab899e27a3d31ac108180a670541">WRITE_BUFFER_SIZE</a> = 260</td></tr>
<tr class="separator:a2541ab899e27a3d31ac108180a670541"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The raw2trace class converts the raw offline trace format to the format expected by analysis tools. It requires access to the binary files for the libraries and executable that were present during tracing. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a26b9006cd8e3411a68fc7b2b2e33a393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26b9006cd8e3411a68fc7b2b2e33a393">&#9670;&nbsp;</a></span>create_essential_header_entries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void dynamorio::drmemtrace::raw2trace_t::create_essential_header_entries </td>
          <td>(</td>
          <td class="paramtype">byte *&amp;&#160;</td>
          <td class="paramname"><em>buf_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedynamorio_1_1drmemtrace.html#a017717a4b9ef5ae1f6d1fef1df834baa">offline_file_type_t</a>&#160;</td>
          <td class="paramname"><em>file_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thread_id_t&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">process_id_t&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes the essential header entries to the given buffer. This is useful for other libraries that want to create a trace that works with our tools like the analyzer framework. </p>

</div>
</div>
<a id="a4d2da19abbafbb382f11dd0a7790749f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2da19abbafbb382f11dd0a7790749f">&#9670;&nbsp;</a></span>do_conversion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string dynamorio::drmemtrace::raw2trace_t::do_conversion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs the conversion from raw data to finished trace files. Returns a non-empty error message on failure. </p>

</div>
</div>
<a id="af3f874404ab4775be97a51499dd1d55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f874404ab4775be97a51499dd1d55e">&#9670;&nbsp;</a></span>do_module_parsing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string dynamorio::drmemtrace::raw2trace_t::do_module_parsing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs the first step of <a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#a4d2da19abbafbb382f11dd0a7790749f">do_conversion()</a> without further action: parses and iterates over the list of modules. This is provided to give the user a method for iterating modules in the presence of the custom field used by drmemtrace that prevents direct use of <a class="el" href="group__drcovlib.html#ga9185bf2631bd142ad91220a5e0f49dfe">drmodtrack_offline_read()</a>. On success, calls the <code>process_cb</code> function passed to <a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#a5150d6f82583b9188c856d49e147b087">handle_custom_data()</a> for every module in the list, and returns an empty string at the end. Returns a non-empty error message on failure.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000026">Deprecated:</a></b></dt><dd><a class="el" href="classdynamorio_1_1drmemtrace_1_1module__mapper__t.html">dynamorio::drmemtrace::module_mapper_t</a> should be used instead. </dd></dl>

</div>
</div>
<a id="adf37e4a9abaaaec9361b50cb90507323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf37e4a9abaaaec9361b50cb90507323">&#9670;&nbsp;</a></span>do_module_parsing_and_mapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string dynamorio::drmemtrace::raw2trace_t::do_module_parsing_and_mapping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This interface is meant to be used with a final trace rather than a raw trace, using the module log file saved from the raw2trace conversion. This routine first calls <a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#af3f874404ab4775be97a51499dd1d55e">do_module_parsing()</a> and then maps each module into the current address space, allowing the user to augment the instruction information in the trace with additional information by decoding the instruction bytes. The routine <a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#a13cb114025e727b1580ebe238a794eae">find_mapped_trace_address()</a> should be used to convert from memref_t.instr.addr to the corresponding mapped address in the current process. Returns a non-empty error message on failure.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000027">Deprecated:</a></b></dt><dd><a class="el" href="classdynamorio_1_1drmemtrace_1_1module__mapper__t.html#a2f354f5e63bb425d729ef5b1a34d13a8">dynamorio::drmemtrace::module_mapper_t::get_loaded_modules()</a> should be used instead. </dd></dl>

</div>
</div>
<a id="a13cb114025e727b1580ebe238a794eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13cb114025e727b1580ebe238a794eae">&#9670;&nbsp;</a></span>find_mapped_trace_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string dynamorio::drmemtrace::raw2trace_t::find_mapped_trace_address </td>
          <td>(</td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>trace_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DR_PARAM_OUT app_pc *&#160;</td>
          <td class="paramname"><em>mapped_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This interface is meant to be used with a final trace rather than a raw trace, using the module log file saved from the raw2trace conversion. When <a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#adf37e4a9abaaaec9361b50cb90507323">do_module_parsing_and_mapping()</a> has been called, this routine can be used to convert an instruction program counter in a trace into an address in the current process where the instruction bytes for that instruction are mapped, allowing decoding for obtaining further information than is stored in the trace. Returns a non-empty error message on failure.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000028">Deprecated:</a></b></dt><dd><a class="el" href="classdynamorio_1_1drmemtrace_1_1module__mapper__t.html#a4377f440ae23d7ac420f022a7faedee6">dynamorio::drmemtrace::module_mapper_t::find_mapped_trace_address()</a> should be used instead. </dd></dl>

</div>
</div>
<a id="ae2bfe59e602f51da667e864093bba009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2bfe59e602f51da667e864093bba009">&#9670;&nbsp;</a></span>get_first_app_pc_for_syscall_template()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">app_pc dynamorio::drmemtrace::raw2trace_t::get_first_app_pc_for_syscall_template </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>syscall_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the app pc of the first instruction in the system call template read for syscall_num. Returns nullptr if it could not find it. </p>

</div>
</div>
<a id="ab5d746b7e5b7a6199a800f09966c7658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d746b7e5b7a6199a800f09966c7658">&#9670;&nbsp;</a></span>get_next_entry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const offline_entry_t* dynamorio::drmemtrace::raw2trace_t::get_next_entry </td>
          <td>(</td>
          <td class="paramtype">raw2trace_thread_data_t *&#160;</td>
          <td class="paramname"><em>tdata</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Point to the next offline entry_t. Will not attempt to dereference past the returned pointer. </p>

</div>
</div>
<a id="a948c0f69e1b899be24ff096ea26de881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a948c0f69e1b899be24ff096ea26de881">&#9670;&nbsp;</a></span>get_next_entry_keep_prior()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const offline_entry_t* dynamorio::drmemtrace::raw2trace_t::get_next_entry_keep_prior </td>
          <td>(</td>
          <td class="paramtype">raw2trace_thread_data_t *&#160;</td>
          <td class="paramname"><em>tdata</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Records the currently stored last entry in order to remember two entries at once (for handling split two-entry markers) and then reads and returns a pointer to the next entry. A subsequent call to unread_last_entry() will put back both entries. Returns an emptry string on success or an error description on an error. </p>

</div>
</div>
<a id="a5150d6f82583b9188c856d49e147b087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5150d6f82583b9188c856d49e147b087">&#9670;&nbsp;</a></span>handle_custom_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string dynamorio::drmemtrace::raw2trace_t::handle_custom_data </td>
          <td>(</td>
          <td class="paramtype">const char *(*)(const char *src, DR_PARAM_OUT void **data)&#160;</td>
          <td class="paramname"><em>parse_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string(*)(<a class="el" href="group__drcovlib.html#ga70dd4ae0fcab1e7c8c090977eeeefa02">drmodtrack_info_t</a> *info, void *data, void *user_data)&#160;</td>
          <td class="paramname"><em>process_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>process_cb_user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *data)&#160;</td>
          <td class="paramname"><em>free_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds handling for custom data fields that were stored with each module via <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ae928b4aceb19475c965eb8de4d7ca07a">drmemtrace_custom_module_data()</a> during trace generation. When <a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#a4d2da19abbafbb382f11dd0a7790749f">do_conversion()</a> or <a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#af3f874404ab4775be97a51499dd1d55e">do_module_parsing()</a> is subsequently called, its parsing of the module data will invoke <code>parse_cb</code>, which should advance the module data pointer passed in <code>src</code> and return it as its return value (or nullptr on error), returning the resulting parsed data in <code>data</code>. The <code>data</code> pointer will later be passed to both <code>process_cb</code>, which can update the module path inside <code>info</code> (and return a non-empty string on error), and <b>free_cb</b>, which can perform cleanup.</p>
<p>A custom callback value <code>process_cb_user_data</code> can be passed to <code>process_cb</code>. The same is not provided for the other callbacks as they end up using the <a class="el" href="group__drcovlib.html#ga33bf1c08f5e69e18e8450652928e0c66">drmodtrack_add_custom_data()</a> framework where there is no support for custom callback parameters.</p>
<p>Returns a non-empty error message on failure. </p>

</div>
</div>
<a id="adb2b0392de28b8cef6c9edc3971bb8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2b0392de28b8cef6c9edc3971bb8e2">&#9670;&nbsp;</a></span>is_maybe_blocking_syscall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool dynamorio::drmemtrace::raw2trace_t::is_maybe_blocking_syscall </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether this system number <em>might</em> block. </p>

</div>
</div>
<a id="a984ec1b674ac2f398600ab0a8ce918d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984ec1b674ac2f398600ab0a8ce918d1">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void dynamorio::drmemtrace::raw2trace_t::log </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The level parameter represents severity: the lower the level, the higher the severity. </p>

</div>
</div>
<a id="a7aa5005defa3e5e815e1d092ef4a2bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa5005defa3e5e815e1d092ef4a2bf0">&#9670;&nbsp;</a></span>log_instruction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void dynamorio::drmemtrace::raw2trace_t::log_instruction </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>decode_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>orig_pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#a984ec1b674ac2f398600ab0a8ce918d1">log()</a> but this disassembles the given PC. </p>

</div>
</div>
<a id="a32eb97dd9b8bfab23e1ffc18f1eab760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32eb97dd9b8bfab23e1ffc18f1eab760">&#9670;&nbsp;</a></span>modmap_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdynamorio_1_1drmemtrace_1_1module__mapper__t.html">module_mapper_t</a>&amp; dynamorio::drmemtrace::raw2trace_t::modmap_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the module mapper. </p>

</div>
</div>
<a id="a7b23bb0d332c07aaa0cc15b6cdfc16c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b23bb0d332c07aaa0cc15b6cdfc16c1">&#9670;&nbsp;</a></span>modvec_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;module_t&gt;&amp; dynamorio::drmemtrace::raw2trace_t::modvec_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the module map. </p>

</div>
</div>
<a id="a3bfbb7021372766b4dc61ae04979210e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bfbb7021372766b4dc61ae04979210e">&#9670;&nbsp;</a></span>on_thread_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool dynamorio::drmemtrace::raw2trace_t::on_thread_end </td>
          <td>(</td>
          <td class="paramtype">raw2trace_thread_data_t *&#160;</td>
          <td class="paramname"><em>tdata</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Callback notifying the currently-processed thread has exited. Subclasses are expected to track record metadata themselves. APIs for extracting that metadata are exposed. </p>

</div>
</div>
<a id="a3ff89209c8224d4de764fbe92ee86143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff89209c8224d4de764fbe92ee86143">&#9670;&nbsp;</a></span>process_marker_additionally()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool dynamorio::drmemtrace::raw2trace_t::process_marker_additionally </td>
          <td>(</td>
          <td class="paramtype">raw2trace_thread_data_t *&#160;</td>
          <td class="paramname"><em>tdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295c">trace_marker_type_t</a>&#160;</td>
          <td class="paramname"><em>marker_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>marker_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DR_PARAM_OUT bool *&#160;</td>
          <td class="paramname"><em>flush_decode_cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs any additional actions for the marker "marker_type" with value "marker_val", beyond writing out a marker record. New records can be written to "buf". Returns whether successful. </p>

</div>
</div>
<a id="a99f00d9f03c626c96f9ff32678164b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f00d9f03c626c96f9ff32678164b92">&#9670;&nbsp;</a></span>process_next_thread_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dynamorio::drmemtrace::raw2trace_t::process_next_thread_buffer </td>
          <td>(</td>
          <td class="paramtype">raw2trace_thread_data_t *&#160;</td>
          <td class="paramname"><em>tdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DR_PARAM_OUT bool *&#160;</td>
          <td class="paramname"><em>end_of_record</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Processes a raw buffer which must be the next buffer in the desired (typically timestamp-sorted) order for its traced thread. For concurrent buffer processing, all buffers from any one traced thread must be processed by the same worker thread, both for correct ordering and correct synchronization. </p>

</div>
</div>
<a id="ac4f6f6f247a72c0e1a1cd27196381a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f6f6f247a72c0e1a1cd27196381a6a">&#9670;&nbsp;</a></span>process_offline_entry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dynamorio::drmemtrace::raw2trace_t::process_offline_entry </td>
          <td>(</td>
          <td class="paramtype">raw2trace_thread_data_t *&#160;</td>
          <td class="paramname"><em>tdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const offline_entry_t *&#160;</td>
          <td class="paramname"><em>in_entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thread_id_t&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DR_PARAM_OUT bool *&#160;</td>
          <td class="paramname"><em>end_of_record</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DR_PARAM_OUT bool *&#160;</td>
          <td class="paramname"><em>last_bb_handled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DR_PARAM_OUT bool *&#160;</td>
          <td class="paramname"><em>flush_decode_cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert starting from in_entry, and reading more entries as required. Sets end_of_record to true if processing hit the end of a record. read_and_map_modules() must have been called by the implementation before calling this API. </p>

</div>
</div>
<a id="a296eb19535563da011525fdde5d22369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296eb19535563da011525fdde5d22369">&#9670;&nbsp;</a></span>read_header()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dynamorio::drmemtrace::raw2trace_t::read_header </td>
          <td>(</td>
          <td class="paramtype">raw2trace_thread_data_t *&#160;</td>
          <td class="paramname"><em>tdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DR_PARAM_OUT <a class="el" href="structdynamorio_1_1drmemtrace_1_1trace__header__t.html">trace_header_t</a> *&#160;</td>
          <td class="paramname"><em>header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the header of a thread, by calling <a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#ab5d746b7e5b7a6199a800f09966c7658">get_next_entry()</a> successively to populate the header values. The timestamp field is populated only for legacy traces. </p>

</div>
</div>
<a id="ae6f878550d53070fb71296f1304e09e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f878550d53070fb71296f1304e09e8">&#9670;&nbsp;</a></span>read_syscall_template_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string dynamorio::drmemtrace::raw2trace_t::read_syscall_template_file </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads entries in the given system call template file. These will be added to the final trace at the locations of the corresponding system call number markers. </p>

</div>
</div>
<a id="af39a7bfc8954256a2d913050bc8f4e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39a7bfc8954256a2d913050bc8f4e7a">&#9670;&nbsp;</a></span>set_modmap_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dynamorio::drmemtrace::raw2trace_t::set_modmap_ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdynamorio_1_1drmemtrace_1_1module__mapper__t.html">module_mapper_t</a> *&#160;</td>
          <td class="paramname"><em>modmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the module mapper. Must be called before <a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#ac4f6f6f247a72c0e1a1cd27196381a6a">process_offline_entry()</a> is called. </p>

</div>
</div>
<a id="ad54f20f0cb2c70e538f4a551ad76ed59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad54f20f0cb2c70e538f4a551ad76ed59">&#9670;&nbsp;</a></span>set_modvec_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dynamorio::drmemtrace::raw2trace_t::set_modvec_ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; module_t &gt; *&#160;</td>
          <td class="paramname"><em>modvec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the module map. Must be called before <a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#ac4f6f6f247a72c0e1a1cd27196381a6a">process_offline_entry()</a> is called. </p>

</div>
</div>
<a id="a8169c0bff3707183b249e3ef606f68bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8169c0bff3707183b249e3ef606f68bd">&#9670;&nbsp;</a></span>write_syscall_template()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dynamorio::drmemtrace::raw2trace_t::write_syscall_template </td>
          <td>(</td>
          <td class="paramtype">raw2trace_thread_data_t *&#160;</td>
          <td class="paramname"><em>tdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedynamorio_1_1drmemtrace.html#a067f98c2dab7fe5329e2ba248836370e">trace_entry_t</a> *&#160;</td>
          <td class="paramname"><em>buf_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>syscall_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes the system call template to the output trace, if any was provided in the system call template file for the given syscall_num. </p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a4c39c4bc5c0dfd521c94e345939e7214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c39c4bc5c0dfd521c94e345939e7214">&#9670;&nbsp;</a></span>dcontext_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* const dynamorio::drmemtrace::raw2trace_t::dcontext_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The pointer to the DR context. </p>

</div>
</div>
<a id="aba91423f830ff5fbaa739a40d3d80dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba91423f830ff5fbaa739a40d3d80dde">&#9670;&nbsp;</a></span>passed_dcontext_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dynamorio::drmemtrace::raw2trace_t::passed_dcontext_ = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether a non-nullptr dcontext was passed to the constructor. </p>

</div>
</div>
<a id="a2541ab899e27a3d31ac108180a670541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2541ab899e27a3d31ac108180a670541">&#9670;&nbsp;</a></span>WRITE_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint dynamorio::drmemtrace::raw2trace_t::WRITE_BUFFER_SIZE = 260</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The trace_entry_t buffer returned by get_write_buffer() is assumed to be at least <a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html#a2541ab899e27a3d31ac108180a670541">WRITE_BUFFER_SIZE</a> large.</p>
<p>WRITE_BUFFER_SIZE needs to be large enough to hold one instruction and its memrefs. Some of the AArch64 SVE scatter/gather instructions have a lot of memref entries. For example ld4b loads 4 registers with byte sized elements, so that is (vl_bits / 8) * 4 entries. With a 512-bit vector length that is (512 / 8) * 4 = 256 memref entries. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drmemtrace/<a class="el" href="raw2trace_8h.html">raw2trace.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.19-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>dynamorio</b></li><li class="navelem"><a class="el" href="namespacedynamorio_1_1drmemtrace.html">drmemtrace</a></li><li class="navelem"><a class="el" href="classdynamorio_1_1drmemtrace_1_1raw2trace__t.html">raw2trace_t</a></li>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 10.90.19831 --- Sat Apr 20 2024 02:24:01 &nbsp; <img border=0 src="favicon.png">
</small></address>
<!--END !GENERATE_TREEVIEW-->
</body>
</html>
